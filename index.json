[{"content":"The Monty Hall problem is an interesting puzzle in probability which has a counter-intuitive answer. In fact, it is documented that many well known mathematicians, PhDs and nobel laureates got the answer wrong too and many people continue to get the answer wrong.\nThe problem The problem goes somewhat like this:\nImagine a game show. There are 3 doors and behind one door there is a car and behind the other 2, goats. The player picks a door hoping to win a car that\u0026rsquo;s behind the door. The game show host opens one of the other doors to reveal a goat (always). Does the player need to switch the choice of his door or stick with his first guess?\nWhen I first saw the problem, I went headlong into solving it and got the answer wrong.\nThe common mistake The usual first solution that is offered is to not switch the chosen door after one of the doors is opened. After this step, most people think there is equal probability of the car being in either of the remaining closed doors. Lot of people got the answer wrong when it was first posed and continue to get it wrong. Wikipedia has documented many reasons why people make this choice of not wanting to switch which is an interesting read.\nThe actual solution (Spoiler alert!) The correct answer is to switch the choice of the door after the game host has revealed a goat by opening one of the two closed doors.\nAn intuitive explanation There is a purely probability based solution described in many places on the internet, which is somewhat of a hard read. Yes, I looked up the answer, but it was kind of unsatisfying, mainly because it was hard to intuitively grasp the answer based on probability. While thinking over this on and off, I chanced to come up with an alternative solution which is also presented elsewhere on the internet.\nTo begin with, there is one car and two goats behind 3 closed doors. So this essentially means there is a higher probability of picking a door with a goat behind it. Let\u0026rsquo;s recall from the definition of probability, in our case:\nThe probability of picking a goat is:\nNumber of goats / total number of all things (goats and cars) = 2 / 3\nSo, statiscally, there is a higher chance of picking a door with a goat behind it in the beginning. Therefore, it makes sense to switch the door after the game show host has opened to reveal a goat behind one of the closed doors.\nIn fact, even if the problem were to be modified as I explain below, the correct answer is to always switch the door.\nLet\u0026rsquo;s say we have 100 closed doors, with 99 goats and 1 car behind them. Now you can immediately see there is more chance (99/100 to be exact) of somebody randomly picking a door with a goat behind it. Now if the game show host opens 98 of the 99 closed doors to reveal 98 goats behind them, leaving only one door unopened, then doesn\u0026rsquo;t it make sense to switch the door that you initially picked?\nSimulation Let\u0026rsquo;s create a simulation to drive home this intuition and to prove that this is indeed the correct answer.\nFirst, let\u0026rsquo;s write a function to create a game. The game consists of a number of doors with 1 car and the rest of them goats. The function returns an array whose elements represent doors and what\u0026rsquo;s behind them, i.e., 1 for car and 0 for goats.\nNow let\u0026rsquo;s run it to see that indeed the car is behind a different door in each game instance (statistically speaking).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import numpy as np def create_game(num_doors=3): \u0026#34;\u0026#34;\u0026#34;Create and return number of doors with one car (represented by 1) in a random position and the rest with goats (represented by 0).\u0026#34;\u0026#34;\u0026#34; # Initialize random number generator rng = np.random.default_rng(np.random.randint(123456789)) doors = np.zeros((num_doors,), dtype=int) # 1 = car, 0 = goat. Initialize car behind one of the doors picked at random. doors[rng.integers(num_doors)] = 1 return doors # Create games with 3 doors print(\u0026#34;Games with 3 doors:\u0026#34;) for i in range(5): new_game_door = create_game(num_doors=3) print(new_game_door) # Create games with 10 doors print(\u0026#34;\\nGames with 10 doors:\u0026#34;) for i in range(5): new_game_door = create_game(num_doors=10) print(new_game_door) Games with 3 doors: [0 1 0] [0 1 0] [1 0 0] [0 1 0] [0 1 0] Games with 10 doors: [0 1 0 0 0 0 0 0 0 0] [0 0 0 0 0 0 0 1 0 0] [0 0 0 0 0 0 0 0 0 1] [0 0 1 0 0 0 0 0 0 0] [0 0 0 0 0 1 0 0 0 0] We can see that the car (1) is set in the arrays above at random positions within each array.\nLet\u0026rsquo;s create a function to select a door in an instance of the game. This function will return the player\u0026rsquo;s choice of the door by sampling a random number from the number of doors.\n1 2 3 4 5 6 7 8 import numpy as np def select_door(game): \u0026#34;\u0026#34;\u0026#34;Select a door from the game (player\u0026#39;s choice at the beginning). Return the index of the selected door.\u0026#34;\u0026#34;\u0026#34; selected_door = np.random.randint(len(game)) return selected_door We then simulate the part where the game show host reveals all the doors that have goats behind them except for one door and the player ends up with two doors to figure out what to do next.\nWe can do this by creating a new array that represents the doors that includes the value of the index (door) that was chosen by the player and the value of the remaining item in the array after revealing all the goats.\nIf the player had selected a door with a car behind it (value 1), then the remaining doors are all goats (0s). The new array will contain elements [1, 0].\nIf the player had selected a door with a goat behind it (value 0), the remaining doors have one car (value 1) and the rest goats (0s). So the new array will have the elements [0, 1] because the game show host has to reveal only the doors with goats behind them which leaves one unopened door with a car behind it.\n1 2 3 4 5 6 7 8 9 10 11 12 13 import numpy as np def reveal_goats(selected_door): \u0026#34;\u0026#34;\u0026#34;Function that returns an array representing the two doors after the game show host has revealed all the goats. The first element in the array represents the door that the player had picked in the beginning. The second element in the array represents the remaining door after rest of the doors were opened to reveal goats.\u0026#34;\u0026#34;\u0026#34; if selected_door == 1: return np.array([1, 0]) else: return np.array([0, 1]) Now, the following two cases are possible:\nPlayer switches the door When the player switches the door, the result is given by the second element of the two element array.\nPlayer does not switch In this case, the result is given by the first element of the two element array.\n1 2 3 4 5 def result(remaining_doors, switch=True): if switch == True: return remaining_doors[1] else: return remaining_doors[0] Results Now that we have all the pieces, we can put them together and run the simulation to study the overall winnings when the player switches and when they do not.\nThe entire code is shown below and is also available in my github repo.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 import numpy as np import matplotlib.pyplot as plt def create_game(num_doors=3): \u0026#34;\u0026#34;\u0026#34;Create and return number of doors with one car (represented by 1) in a random position and the rest with goats (represented by 0).\u0026#34;\u0026#34;\u0026#34; # Initialize random number generator rng = np.random.default_rng(np.random.randint(123456789)) doors = np.zeros((num_doors,), dtype=int) # 1 = car, 0 = goat. Initialize car behind one of the doors picked at random. doors[rng.integers(num_doors)] = 1 return doors def select_door(game): \u0026#34;\u0026#34;\u0026#34;Select a door from the game (player\u0026#39;s choice at the beginning). Return the index of the selected door.\u0026#34;\u0026#34;\u0026#34; selected_door = np.random.randint(len(game)) return selected_door def reveal_goats(selected_door): \u0026#34;\u0026#34;\u0026#34;Function that returns an array representing the two doors after the game show host has revealed all the goats. The first element in the array represents the door that the player had picked in the beginning. The second element in the array represents the remaining door after rest of the doors were opened to reveal goats.\u0026#34;\u0026#34;\u0026#34; if selected_door == 1: return np.array([1, 0]) else: return np.array([0, 1]) def result(doors, switch=True): \u0026#34;\u0026#34;\u0026#34;Function that returns the eventual choice of the player. If the player switches, return the second element in the array, else return the first.\u0026#34;\u0026#34;\u0026#34; if switch is True: return doors[1] else: return doors[0] # Play 100 times the game of 3 doors. accum_result_no_switch = [] accum_result_switch = [] res_no_switch = 0 res_switch = 0 for i in range(100): new_game = create_game(num_doors=3) selected_door = select_door(new_game) final_doors = reveal_goats(selected_door) res_no_switch += result(final_doors, switch=False) res_switch += result(final_doors, switch=True) accum_result_no_switch.append(res_no_switch) accum_result_switch.append(res_switch) plt.plot(np.arange(len(accum_result_no_switch)), accum_result_no_switch, label=\u0026#39;Accumulated Wins (No Switch)\u0026#39;) plt.plot(np.arange(len(accum_result_switch)), accum_result_switch, label=\u0026#39;Accumulated Wins (Switch)\u0026#39;) plt.xlabel(\u0026#34;Number of games played\u0026#34;) plt.ylabel(\u0026#34;Wins\u0026#34;) plt.title(\u0026#34;Number of Doors = 3\u0026#34;) plt.legend() plt.savefig(\u0026#34;100games3doors.png\u0026#34;) # The next return statement was needed for org-mode for creating this blog return \u0026#34;100games3doors.png\u0026#34; As we can see in the plot, the overall winnings is higher in the long run if the player chooses to switch the door. This is of course a statistical result, which means that there is about 1/3 probability of the player winning even if he chooses not to switch. The plot is very similar to this wikipedia version. Due to the probabilistic nature of the game/simulation, the plots will look slightly different each time the simulation is run.\nAnd now! Monty Hall problem with 100 doors ;) If you run the simulation for a 100 door game (1 car, 99 goats), it\u0026rsquo;s quite evident from the plot below that it makes perfect sense to switch! The chances of winning in this case if you don\u0026rsquo;t switch is miniscule. And now! Monty Hall problem with a million doors Ok, now I know I am pushing it. Until later, bye and hope this was interesting and fun to read.\n","permalink":"http://shalbhav.github.io/posts/monty-hall-sim/","summary":"The Monty Hall problem is an interesting puzzle in probability which has a counter-intuitive answer. In fact, it is documented that many well known mathematicians, PhDs and nobel laureates got the answer wrong too and many people continue to get the answer wrong.\nThe problem The problem goes somewhat like this:\nImagine a game show. There are 3 doors and behind one door there is a car and behind the other 2, goats.","title":"The Monty Hall Problem: Intuition and Simulation"},{"content":"Emacs org-mode is an emacs major mode used for note keeping, project planning and for creating documents and articles. It has many export options from markdown to pdf to latex. While all this is great for document generation, it can also be used for creating presentations with org-reveal. Still, this needs a browser and sometimes you really have more text than a few bullet points and want a simpler option to just focus on the text under each heading by narrowing to each heading as you present.\nOrg-mode has the commands to move to next and previous headings and this combined with narrowing and widening options can really help one to focus on the text that is being presented at the moment.\nThe following elisp functions define how to focus the org text on each heading. Place this in the init.el emacs configuration file and bind it to the keys of your choice.\nThe functions use the org-mode builtin functions org-forward-heading-same-level and org-backward-heading-same-level to move to headings. Since these commands are themselves interactive commands we need to call them using the call-interactively function. widen is needed to make headings momentarily visible so that we can jump to the next/previous headings. Call org-narrow-to-subtree to focus only on the heading to be presented.\n(defun narrow-to-next-heading () \u0026#34;Narrow to next heading\u0026#34; (interactive) (widen) (call-interactively \u0026#39;org-forward-heading-same-level nil) (org-narrow-to-subtree)) (with-eval-after-load \u0026#39;org (add-hook \u0026#39;org-mode-hook (lambda () (local-set-key (kbd \u0026#34;C-c f\u0026#34;) \u0026#39;narrow-to-next-heading)))) (defun narrow-to-prev-heading () \u0026#34;Narrow to prev heading\u0026#34; (interactive) (widen) (call-interactively \u0026#39;org-backward-heading-same-level nil) (org-narrow-to-subtree)) (with-eval-after-load \u0026#39;org (add-hook \u0026#39;org-mode-hook (lambda () (local-set-key (kbd \u0026#34;C-c b\u0026#34;) \u0026#39;narrow-to-prev-heading)))) To highlight the current subtree or heading, you can use (org-narrow-to-subtree) / (C-x n s) with cursor inside the block. To move to next/previous subtrees/headings you can use the keybindings defined for those functions. In my case, I\u0026rsquo;ve bound them to C-c f and C-c b to move forward and backward in the subtrees respectively.\nTo get back to the entire document run C-x n w to widen. The gif shows how this works in action.\nTODO\nIt would be nice to increase/decrease font size of the highlighted section based on the current window size.\nShortly after I did this, I learnt of a emacs package called org-present which might do all this and more. I plan on trying it out sometime in the future. If nothing, this helped me to brush up on some emacs lisp.\n","permalink":"http://shalbhav.github.io/posts/org-mode-present-focus/","summary":"Emacs org-mode is an emacs major mode used for note keeping, project planning and for creating documents and articles. It has many export options from markdown to pdf to latex. While all this is great for document generation, it can also be used for creating presentations with org-reveal. Still, this needs a browser and sometimes you really have more text than a few bullet points and want a simpler option to just focus on the text under each heading by narrowing to each heading as you present.","title":"Presenting with Emacs Org-mode"},{"content":"Mosquito bats work great for killing mosquitoes and flies. Until they don\u0026rsquo;t work! They hardly last one mosquito generation. It turns out that the rechargeable battery in them go bad fairly quickly. So as a small hack, I took out the cheap battery they come with and replaced it with a decent rechargeable LiIon 3.7v 2200mah one. You have to modify the battery housing a little bit by carving out some extra bits of plastic to make the 18650 type battery to fit. It seems a bit more solid now. Now the mosquitoes won\u0026rsquo;t know what zapped their asses.\nMyaahhaaha!\n","permalink":"http://shalbhav.github.io/posts/extend-life-mosquito-bat/","summary":"Mosquito bats work great for killing mosquitoes and flies. Until they don\u0026rsquo;t work! They hardly last one mosquito generation. It turns out that the rechargeable battery in them go bad fairly quickly. So as a small hack, I took out the cheap battery they come with and replaced it with a decent rechargeable LiIon 3.7v 2200mah one. You have to modify the battery housing a little bit by carving out some extra bits of plastic to make the 18650 type battery to fit.","title":"Extending life of the Mosquito Bat"},{"content":"Apparently a container does not even need an OS whereas VMs do. Container != VM, but I never stopped to think about this before. Processes within the container can directly talk to the kernel on which the container is running. Most containers are built with a base OS image. Turns out you can create an image without a base OS by pulling the scratch image, that contains nothing.\nLet\u0026rsquo;s create a small c program that is statically compiled.\n$ cat small.c #include \u0026lt;unistd.h\u0026gt; int main() { write(1, \u0026#34;Hi!\u0026#34;, 3); } $ gcc -o small small.c --static Just 852kB!\n$ ls -l small --block-size=k -rwxrwxr-x 1 username username 852K Aug 5 15:34 small This executable has everything it needs to run and does not need an OS. There is nothing specific to Ubuntu, for example. It just prints \u0026ldquo;Hi!\u0026rdquo;.\n$ ./small Hi! Let\u0026rsquo;s build a Docker image with this executable inside it.\n# Run this in the same directory where the executable \u0026#39;small\u0026#39; is. $ cat Dockerfile FROM scratch ADD small /small CMD [\u0026#34;/small\u0026#34;] $ docker build -t small-image -f Dockerfile . $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE small-image latest 46ad701a4cce About an hour ago 872kB It\u0026rsquo;s about 872kB which is almost the same size as the executable small. This should convince you that the scratch image has nothing in it and we can verify this a functional image without a base OS, directly talking to the kernel.\n$ docker run small Hi! Hope you found this useful!\n","permalink":"http://shalbhav.github.io/posts/container-no-os/","summary":"Apparently a container does not even need an OS whereas VMs do. Container != VM, but I never stopped to think about this before. Processes within the container can directly talk to the kernel on which the container is running. Most containers are built with a base OS image. Turns out you can create an image without a base OS by pulling the scratch image, that contains nothing.\nLet\u0026rsquo;s create a small c program that is statically compiled.","title":"A container does not need an OS"}]